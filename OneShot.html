<!doctype html>
<style>*{padding:0; margin: 0}</style>
<html>
    
<head>
    <meta charset="utf-8">
    <title>Hello World</title>
</head>
    <script src="pixi.min.js"></script>
    <script src="bump.js"></script>
    <body>
        <script type="text/javascript">
            //Aliases
            var Container = PIXI.Container,
                autoDetectRenderer = PIXI.autoDetectRenderer,
                loader = PIXI.loader,
                resources = PIXI.loader.resources,
                TextureCache = PIXI.utils.TextureCache,
                Texture = PIXI.Texture,
                Text = PIXI.Text,
                Graphics = PIXI.Graphics,
                Sprite = PIXI.Sprite;
        
            
            var message = new Text("heesdfsdflo", {fontFamily: "Arial", fontSize: 32, fill: "white"}
            );
            message.position.set(50,256);
            
            var bullets = [],
                boxes = [],
                targets = [],
                tpath = new Graphics(),
                targetsHit = [];   

            var state,
                shoot,
                angleGun,
                gameWidth = 512,
                gameHeight = 512,
                gameInfo = 50,
                gameBorder = 10,
                bulletSpeed = 10,
                bulletBounce = 10,
                bulletHeight = 30,
                bulletWidth = 10,
                wallWidth = 50,
                wallHeight = 50,
                stage = new Container(),
                renderer = autoDetectRenderer(gameWidth,gameHeight + gameInfo);
            
            document.body.appendChild(renderer.view);
            
            loader
                .add("mario2.png")
                .load(setup);

            function setup(){
                var tracePath = new Graphics(),
                    gamebox = new Graphics(),
                    gun = new Graphics();

                var path;

                gamebox.beginFill(0x5B5C5C);
                gamebox.drawRect(gameBorder, gameBorder, gameWidth - gameBorder * 2, gameHeight - gameBorder );
                gamebox.endFill();
                stage.addChild(gamebox);
                
                gun.lineStyle(10,0xFFFFFF,1);
                gun.moveTo(256,520);
                gun.lineTo(256,482);

                createWalls(3);
                var random_angle = 0;
                while(targets.length < 5 || targetQuad() == false || checkIfPixelPerfect(random_angle) == false){
                    targets = [];
                    random_angle = createTargets();

                    
                }
                targets.forEach(function(target){
                    stage.addChild(target);
                });
                



                document.body.addEventListener("mousemove", function (e){

                    angleGun = (Math.atan2((gameHeight - e.clientY) ,((gameWidth / 2) - e.clientX )));
                    path =  new createPath((gameWidth / 2), gameHeight, angleGun, bulletBounce, 10, 10, bulletSpeed);
                    path = getPathHits(path);
                    tracePath.clear();
                    tracePath.lineStyle(2, 0xFF0000, 1);
                    tracePath.moveTo((gameWidth / 2),gameHeight);
                    path.cords.forEach(function(cord){
                        tracePath.lineTo(cord.xpos, cord.ypos);
                    });

                    gun.clear(); 
                    gun.lineStyle(10,0xFFFFFF,1);
                    gun.moveTo(256,520);
                    gun.lineTo(256 - (30 * Math.cos(angleGun)) , 512 - (30 * Math.sin(angleGun))); 

                });
                
                document.body.addEventListener("click", function (e){
                    console.log("y: " + e.clientY);
                    if(e.clientY < 512){
                        if(bullets.length == 0){
                            var angleBullet = (Math.atan2((gameHeight - e.clientY) ,((gameWidth / 2) - e.clientX )));
                            var bullet = createBullet(angleBullet);
                            bullets.push(bullet);
                            stage.addChild(bullet);
                        }
                    }
                });

                stage.addChild(gun);
                stage.addChild(message);
                stage.addChild(tracePath);

                renderer.render(stage);

                gameLoop();
            }

            function createBullet(angle){
                var bullet = new Graphics();
                bullet.beginFill(0x239569);
                bullet.drawRect(0 , 0, 10, 10);
                bullet.x= (gameWidth / 2) - (bulletHeight * Math.cos(angle));
                bullet.y = gameHeight - (bulletHeight * Math.sin(angle));
                bullet.xv = (Math.cos(angle));
                bullet.yv = (Math.sin(angle));
                bullet.bounce = bulletBounce;
                bullet.endFill();
                return bullet;
            }

            function createWalls(numWalls){
                var xsplit = gameWidth / numWalls,
                    ysplit = (gameHeight - 100) / numWalls,
                    xPad = xsplit - wallWidth,
                    yPad = ysplit - wallHeight;
                
                for(var i = 0; i < numWalls; i++){
                    for(var j = 0; j < numWalls; j++){
                        var randx = Math.floor(Math.random() * xPad) + 1;
                        var randy = Math.floor(Math.random() * yPad) + 1;
                        //Dont make wall in front of gun
                        if(!((i == Math.floor(numWalls/2)) && j == Math.ceil(numWalls / 2))){ 
                            if(((i*xsplit) + randx) < gameBorder){
                                randx = gameBorder;
                            }else if(((i*xsplit) + randx + wallWidth) > (gameWidth - gameBorder)){
                                randx = gameWidth - gameBorder;
                            }
                            if(((j * ysplit) + randy) < gameBorder){
                                randy = gameBorder;
                            }else if(((j * ysplit) + randy + wallHeight) > (gameHeight - gameBorder)){
                                randy = gameHeight - gameBorder;
                            }
                            createWall((i*xsplit) + randx , (j * ysplit) + randy, wallWidth, wallHeight);
                        }
                    }
                } 
            }
            

            function createWall(x,y,w,h){
                var box = new Graphics();
                box.beginFill(0xF6CCFF);
                box.drawRect(x,y,w,h);
                box.xpos = x;
                box.ypos = y;
                box.endFill();

                boxes.push(box);
                stage.addChild(box);
            }

            function createTargets(){
                //Convert random angle to rad
                var randAngle = (Math.floor(Math.random() * 175) + 1) * Math.PI / 180;
                targetPath =  new createPath((gameWidth / 2), gameHeight, randAngle, bulletBounce, 10, 10, bulletSpeed);
                targetPath = getPathHits(targetPath);

                var startx = gameWidth / 2;
                var starty = gameHeight;
                targetPath.cords.forEach(function(cord){ 
                    var pathWidth = (cord.xpos - startx),
                        pathHeight = (cord.ypos - starty);
                        
                    var testx, texty;
                    var foundPos = false;
                    var loopCount = 0;

                    //Find and create location of target
                    while(foundPos == false && loopCount < 50){
                        var randx = Math.floor(Math.random() * pathWidth) + 1,
                            randy = Math.floor(Math.random() * pathHeight) + 1,
                            target = new Sprite(resources["mario2.png"].texture);

                        var m = (pathHeight/pathWidth),
                            b = cord.ypos - (m * cord.xpos),
                            ypos;
                        if(startx > cord.xpos){
                            testx = cord.xpos - randx;
                        }else{
                            testx = cord.xpos - randx;
                        }

                        ypos = m * testx + b;                     
                        target.x = (testx - target.width / 2);
                        target.y = ypos - target.height / 2;

                        if(!hitTargetOnPath(target)){
                            targets.push(target);
                            foundPos = true;
                        }else{
                            loopCount++;
                        }
                    }
                    startx = cord.xpos;
                    starty = cord.ypos;
                });
                
                drawAnswer();

                return randAngle;
            }

            function drawAnswer(){
                tpath.clear();
                tpath.lineStyle(2, 0x0000FF, 1);
                tpath.moveTo((gameWidth / 2),gameHeight);
                targetPath.cords.forEach(function(cord){
                    tpath.lineTo(cord.xpos, cord.ypos);
                });
                stage.addChild(tpath);
            }

            //Change padding of answer
            function checkIfPixelPerfect(random_angle){
                debugger;
                //Add angle difference to answer
                var addAngle = .5 * Math.PI / 180 
                var bullet = createBullet(random_angle + addAngle);
                targetsHit = [];
                
                while(bulletBounce > 0){
                    hitTarget(bullet);
                    hitBox(bullet);
                    hitWall(bullet);
                    
                    if(bullet.bounce > 0){
                        bullet.x -= (bulletSpeed * bullet.xv);
                        bullet.y -= (bulletSpeed * bullet.yv);
                    }else{
                        if(targets.length == 0){
                            targetsHit.forEach(function(target){
                                targets.push(target);
                            });
                            targetsHit = [];
                            return true;
                        }else{
                            targets = [];
                            targetsHit = [];
                            return false;
                        }
                    }
                }
            }

            //Target in all 4 quads
            function targetQuad(){
                var q1 = false,
                    q2 = false, 
                    q3 = false,
                    q4 = false;
                    quad = 0;

                targets.forEach(function(target){
                    if(target.x < (gameWidth /2) && target.y < (gameHeight / 2)){
                        if(!q1){
                            q1 = true;
                            quad++;
                        }
                    }else if(target.x > (gameWidth /2) && target.y < (gameHeight / 2)){
                        if(!q2){
                            q2 = true;
                            quad++;
                        }
                    }else if(target.x < (gameWidth /2) && target.y > (gameHeight / 2)){
                        if(!q3){
                            q3 = true;
                            quad++;
                        }
                    }else if(target.x > (gameWidth /2) && target.y > (gameHeight / 2)){
                        if(!q4){
                            q4 = true;
                            quad++;
                        }
                    }
                });

                


                if(quad > 3){
                    return true;
                }else{
                    return false;
                }



            }

            function createTarget(x ,y){   
                var target = new Sprite(resources["mario2.png"].texture);
                target.x = x;
                target.y = y;
                targets.push(target);
                stage.addChild(target);
            }
            
            function gameLoop(){
                requestAnimationFrame(gameLoop);
                message.text = targets.length;
                
                bullets.forEach(function(bullet){
                    hitTarget(bullet);
                    hitBox(bullet);
                    hitWall(bullet);
                    if(bullet.bounce > 0){
                        bullet.x -= (bulletSpeed * bullet.xv);
                        bullet.y -= (bulletSpeed * bullet.yv);
                    }else{
                        bullet.clear();
                        bullets.pop();
                        if(targets.length == 0){
                            message.text = "win";
                        }else{
                            targetsHit.forEach(function(target){
                                targets.push(target);
                                stage.addChild(target);
                            });
                            targetsHit = [];
                        }
                    }
                });
                renderer.render(stage); 
            }

            function createPath(xpos, ypos, angle, bounce, width, height, speed){
                this.xpos = xpos;
                this.ypos = ypos;
                this.bulletWidth = width;
                this.bulletHeight = height;
                this.xv = Math.cos(angle);
                this.yv = Math.sin(angle);
                this.bulletSpeed = speed;
                this.angle = angle;
                this.bounce = bounce;
                this.cords = [];
            }
            
            function getPathHits(path){
                while(path.bounce > 0){
                    if(path.xpos < gameBorder || (path.xpos + path.bulletWidth) > (gameWidth - gameBorder)){
                        path.bounce--;
                        path.xv *= -1;
                        var cord = {
                            xpos: path.xpos,
                            ypos: path.ypos
                        }
                        path.cords.push(cord);
                    }
                    else if(path.ypos < gameBorder || (path.ypos) > gameHeight){
                        path.bounce--;
                        path.yv *= -1;  
                        var cord = {
                            xpos: path.xpos,
                            ypos: path.ypos
                        }
                        path.cords.push(cord);             
                    }else{
                        boxes.forEach(function(box){
                            //Check if there a collision happening
                            if((path.ypos + path.bulletHeight) > box.ypos && 
                                path.ypos < (box.ypos + box.height) && 
                                (path.xpos + path.bulletWidth) > box.xpos && 
                                path.xpos < (box.xpos + box.width)){
                                
                                //Find axis of collision
                                var vectorX = (path.xpos + Math.abs(path.bulletWidth / 2)) - (box.xpos + Math.abs(box.width / 2));
                                var vectorY = (path.ypos + Math.abs(path.bulletHeight / 2)) - Math.abs(box.ypos + (box.height / 2));
                                var totalHalfWidth = Math.abs(path.bulletWidth / 2) + Math.abs(box.width / 2);
                                var totalHalfHeight = Math.abs(path.bulletHeight /2 ) +  Math.abs(box.height / 2);
                                var overlapX = totalHalfWidth - Math.abs(vectorX);
                                var overlapY =  totalHalfHeight - Math.abs(vectorY);

                                //Collsion on Top/Bottom
                                if(overlapX >= overlapY){
                                    if(vectorY > 0){
                                        path.ypos += overlapY;
                                        
                                    }else{
                                        path.ypos -= overlapY;
                                        
                                    }
                                    path.yv *= -1;
                                    var cord = {
                                        xpos: path.xpos,
                                        ypos: path.ypos
                                    }
                                    path.cords.push(cord); 
                                }
                                //Collsion on Left/Right
                                else{
                                    if(vectorX > 0){
                                        path.xpos += overlapX;
                                    }else{
                                        path.xpos -= overlapX;
                                    }
                                    path.xv *= -1;
                                    var cord = {
                                        xpos: path.xpos,
                                        ypos: path.ypos
                                    }
                                    path.cords.push(cord); 
                                }
                                path.bounce--;
                            }
                        });
                    }
                    path.xpos -= (path.bulletSpeed * path.xv); 
                    path.ypos -= (path.bulletSpeed * path.yv);             
                }
                return path;   
            }
            
            function hitTarget(bullet){
                var hit, totalWidth, totalHeight, centerWidth, centerHeight;
                var deleteIndex = 0;
                targets.forEach(function(target){
                    if((bullet.y  + bullet.height) > target.y && 
                        bullet.y < (target.y + target.height) && 
                        (bullet.x + bullet.width) > target.x && 
                        bullet.x < (target.x + target.width)){
                            stage.removeChild(target);
                            targets.splice(deleteIndex, 1);
                            targetsHit.push(target);
                    }else{
                        deleteIndex++;
                    }
                });
            }

            function hitTargetOnPath(target){
                var hit = false;
                boxes.forEach(function(box){
                    if(target.x < gameBorder || (target.x + target.width) > (gameWidth - gameBorder)){
                        hit =  true;
                    }
                    if(target.y < gameBorder || (target.y + target.height)  > gameHeight){
                        hit =  true;
                    }
                    //Check if there a collision happening
                    if((target.y + target.height) > box.ypos && 
                        target.y < (box.ypos + box.height) && 
                        (target.x + target.width) > box.xpos && 
                        target.x < (box.xpos + box.width)){
                            hit = true;
                    }
                });
                targets.forEach(function(target2){
                    if((target.y + target.height) > target2.y && 
                    target.y < (target2.y + target2.height) && 
                    (target.x + target.width) > target2.x && 
                    target.x < (target2.x + target2.width)){
                            hit = true;
                    }
                });
                return hit;
            } 

            function hitBox(bullet){
                boxes.forEach(function(box){
                    //Check for collision
                    if((bullet.y  + bullet.height) > box.ypos && 
                        bullet.y < (box.ypos + box.height) && 
                        (bullet.x + bullet.width) > box.xpos && 
                        bullet.x < (box.xpos + box.width)){
                            //Find axis of collision
                            var vectorX = (bullet.x + Math.abs(bullet.width / 2)) - (box.xpos + Math.abs(box.width / 2));
                            var vectorY = (bullet.y + Math.abs(bullet.height / 2) ) - Math.abs(box.ypos + (box.height / 2));
                            var totalHalfWidth = Math.abs(bullet.width / 2) + Math.abs(box.width / 2);
                            var totalHalfHeight = Math.abs(bullet.height / 2) + Math.abs(box.height / 2);
                            var overlapX = totalHalfWidth - Math.abs(vectorX);
                            var overlapY =  totalHalfHeight - Math.abs(vectorY);

                            //Collsion on Top/Bottom
                            if(overlapX >= overlapY){
                                if(vectorY > 0){
                                    bullet.y += overlapY;
                                    
                                }else{
                                    bullet.y -= overlapY;
                                }
                                    bullet.yv *= -1;
                            }
                            //Collision on left/right
                            else{
                                if(vectorX > 0){
                                    bullet.x += overlapX;
                                }else{
                                    bullet.x -= overlapX;
                                }
                                    bullet.xv *= -1;
                            }
                        bullet.bounce--;
                    }
                });
            }

            function hitWall(bullet) {
                if(bullet.x < gameBorder || (bullet.x + bulletWidth) > (gameWidth - gameBorder)){
                    bullet.bounce--;
                    bullet.xv *= -1;
                }
                if(bullet.y < gameBorder || bullet.y > gameHeight){
                    bullet.bounce--;
                    bullet.yv *= -1;
                }         
            }
            
        </script>
    </body>
</html>