<!doctype html>
<style>*{padding:0; margin: 0}</style>
<html>
    
<head>
    <meta charset="utf-8">
    <title>One Bullet</title>
</head>
    <script src="pixi.min.js"></script>  
    <body>
        <script type="text/javascript">
            //Aliases
            var Container = PIXI.Container,
                autoDetectRenderer = PIXI.autoDetectRenderer,
                loader = PIXI.loader,
                resources = PIXI.loader.resources,
                TextureCache = PIXI.utils.TextureCache,
                Texture = PIXI.Texture,
                Text = PIXI.Text,
                Graphics = PIXI.Graphics,
                Sprite = PIXI.Sprite;
       
            var messageBounce, messageScore, tracePath, messageTargets, timeText, gameoverText;

            var bullets = [],
                boxes = [],
                targets = [],
                tpath = new Graphics(),
                targetsHit = [];   

            var state,
                timerCount,
                timeElapsed = 30,
                time = timeElapsed,
                score = 0,
                shoot,
                angleGun,
                gameWidth = 512,
                gameHeight = 512,
                gameInfo = 100,
                gameBorder = 10,
                bulletSpeed = 10,
                bulletBounce = 6,
                minTargets= 1,
                bulletHeight = 10,
                bulletWidth = 10,
                wallWidth = 50,
                wallHeight = 50,
                numWalls = 2,
                stopTime = false,
                numRows = 1;
                stage = new Container(),
                stageSettings = new Container(),
                menuStage = new Container(),
                renderer = autoDetectRenderer(gameWidth,gameHeight + gameInfo);

            

                stage.interactive = true;
                stage.hitArea = new PIXI.Rectangle(0,0,gameWidth, gameHeight+gameInfo);

                stageSettings.interactive = true;
                stageSettings.hitArea = new PIXI.Rectangle(0,0,gameWidth, gameHeight+gameInfo);

                menuStage.interactive=true;
                menuStage.hitArea = new PIXI.Rectangle(0,0,gameWidth, gameHeight+gameInfo);
                // stage.click = function(mouseData){
                //     console.log("moving mouse");
                // }

            renderer.backgroundColor = 0x0e242d;
            // var newLevel = createLevel(10,10,10,10,50,50, 3);
            document.body.appendChild(renderer.view);
            
            loader
                .add("button.png")
                .add("targetsmall.png")
                .add("boxsmall.png")
                .add("gun1.png")
                .load(mainMenu);

            function setup(){
                var gamebox = new Graphics(),
                    gameOutline = new Graphics(),
                    gun = new Graphics(),
                    buttonBounce = new Sprite(resources["button.png"].texture),
                    buttonSkip = new Sprite(resources["button.png"].texture),
                    buttonScore = new Sprite(resources["button.png"].texture),
                    messageAnswer = new Text("Answer", {fontFamily: "Arial", fontSize: 24, fill: "white"}),
                    buttonAnswer = new Sprite(resources["button.png"].texture),
                    buttonTargets = new Sprite(resources["button.png"].texture),
                    messageMainMenu = new Text("Main Menu", {fontFamily: "Arial", fontSize: 24, fill: "white"}),
                    buttonMainMenu = new Sprite(resources["button.png"].texture),
                    lazerGun = new Sprite(resources["gun1.png"].texture);
                    
                var path, pathAim, tracePathAim;
                state = play;
                tracePath = new Graphics();
                tracePathAim = new Graphics();
                messageTargets = new Text("Targets: " + targets.length, {fontFamily: "Arial", fontSize: 24, fill: "white"});                
                messageBounce = new Text("Bounces: "  + bulletBounce, {fontFamily: "Arial", fontSize: 24, fill: "white"});
                messageScore = new Text("Score:" + score, {fontFamily: "Arial", fontSize: 24, fill: "white"});
                timeText = new Text("Time: " + time, {fontFamily: "Arial", fontSize: 24, fill: "white"});
                var messageSkip = new Text("Skip", {fontFamily: "Arial", fontSize: 24, fill: "white"});

                timeText.position.set(gameWidth - 127, gameHeight - 24);
                messageBounce.position.set(gameBorder,gameHeight +  12);            
                messageScore.position.set(gameWidth - 127 ,gameHeight +  12);
                messageSkip.position.set(gameWidth/2 - messageSkip.width/2, gameHeight + 12 + 6);
                messageAnswer.position.set(gameWidth/2 - messageAnswer.width/2, gameHeight + 60);
                messageTargets.position.set(gameBorder,gameHeight +  40);
                messageMainMenu.position.set(gameWidth - 137 ,gameHeight +  40);

                buttonBounce.x = gameBorder - 6;
                buttonBounce.y = gameHeight +  12;  
                buttonBounce.scale.y = 0.5; 

                buttonTargets.x = gameBorder - 6;
                buttonTargets.y = gameHeight +  40;  
                buttonTargets.scale.y = 0.5; 


                buttonScore.x = gameWidth - 150 - 6;
                buttonScore.y = gameHeight +  12;  
                buttonScore.scale.y = 0.5;

                buttonMainMenu.x = gameWidth - 150 - 6;
                buttonMainMenu.y = gameHeight +  40;  
                buttonMainMenu.scale.y = 0.5;
                buttonMainMenu.interactive = true;
                buttonMainMenu.click = function(mouseData){
                    score = 0;
                    stopTime = true;
                    stage.visible = false;
                    stageSettings.visible = false;
                    menuStage.visible = true;
                    // settingsStage();
                    state = menuState;
                    console.log("settings");
                }

                buttonSkip.interactive = true;
                buttonSkip.click = function(mouseData){
                    skip = true;
                    level();
                    messageScore.text = "Score: " + score;
                    messageBounce.text = "Bounces: " + bulletBounce;
                }

                buttonAnswer.x = gameWidth/2 - buttonAnswer.width/2;
                buttonAnswer.y = gameHeight + 55;
                buttonAnswer.scale.y = 0.8;

                buttonAnswer.interactive = true;
                buttonAnswer.click = function(mouseData){
                    drawAnswer();
                }

                buttonSkip.x = gameWidth/2 - buttonSkip.width/2;
                buttonSkip.y = gameHeight + 12;
                buttonSkip.scale.y = 0.8;

                gamebox.beginFill(0x23556b);
                gamebox.drawRect(gameBorder, gameBorder, gameWidth - gameBorder * 2, gameHeight - gameBorder );
                gamebox.endFill();

                gameOutline.beginFill(0x62cffc);
                gameOutline.drawRect(gameBorder / 2, gameBorder / 2, gameWidth - gameBorder , gameHeight );
                gameOutline.endFill();
                stage.addChild(gameOutline);
                stage.addChild(gamebox);
                
                // gun.lineStyle(10,0xFFFFFF,1);
                // gun.moveTo(256,520);
                // gun.lineTo(256,482);

                lazerGun.x = (gameWidth/2 );
                lazerGun.y = (gameHeight);
                lazerGun.anchor.set(.5,1);
                
                
                
                
                // settingsStage();
                // mainMenu();
                // level();

                
                document.body.addEventListener("mousemove", function (e){
                    angleGun = (Math.atan2((gameHeight - e.clientY) ,((gameWidth / 2) - e.clientX )));
                    lazerGun.rotation = Math.atan2((e.clientX - lazerGun.x), (lazerGun.y - e.clientY));
                    console.log("posx" + lazerGun.x + " posy " + lazerGun.position.y);

                    pathAim =  new createPath((gameWidth / 2), gameHeight, angleGun, 2, 10, 10, bulletSpeed);
                    pathAim = getPathHits(pathAim);
                    tracePathAim.clear();
                    tracePathAim.lineStyle(2, 0xFF0000, 1);
                    tracePathAim.moveTo((gameWidth / 2),gameHeight);
                    pathAim.cords.forEach(function(cord){
                        tracePathAim.lineTo(cord.xpos, cord.ypos);
                    });
                    stage.addChild(tracePathAim);

                    if(tpath.answer){
                        path =  new createPath((gameWidth / 2), gameHeight, angleGun, bulletBounce, 10, 10, bulletSpeed);
                        path = getPathHits(path);
                        tracePath.clear();
                        tracePath.lineStyle(2, 0xFF0000, 1);
                        tracePath.moveTo((gameWidth / 2),gameHeight);
                        path.cords.forEach(function(cord){
                            tracePath.lineTo(cord.xpos, cord.ypos);
                        });
                        stage.addChild(tracePath);
                    }

                    // gun.clear(); 
                    // gun.lineStyle(10,0xFFFFFF,1);
                    // gun.moveTo(256,gameHeight);
                    // gun.lineTo((gameWidth / 2) - (30 * Math.cos(angleGun)) , gameHeight - (30 * Math.sin(angleGun))); 

                });
                
                document.body.addEventListener("click", function (e){

                    if(e.clientY < 512){
                        if(bullets.length == 0){
                            var angleBullet = (Math.atan2((gameHeight - e.clientY) ,((gameWidth / 2) - e.clientX )));
                            var bullet = createBullet(angleBullet);
                            bullets.push(bullet);
                            stage.addChild(bullet);
                        }
                    }
                });

                // stage.addChild(gun);
                stage.addChild(timeText);
                stage.addChild(buttonBounce);
                stage.addChild(messageBounce);
                stage.addChild(buttonScore);
                stage.addChild(messageScore);
                stage.addChild(buttonSkip);
                stage.addChild(messageSkip);
                stage.addChild(buttonAnswer);
                stage.addChild(messageAnswer);
                stage.addChild(buttonTargets);
                stage.addChild(messageTargets);
                stage.addChild(buttonMainMenu);
                stage.addChild(messageMainMenu);
                stage.addChild(lazerGun);

                
                // renderer.render(menuStage);
                // gameLoop();
            }

            function timeLeft(){
                timeText.text = "Time: " + (--time);
                console.log("time: " + time);
                if(time == -1 || stopTime){
                    console.log("Game over");
                    clearInterval(timerCount);
                    stopTime = false;
                    time = timeElapsed;
                    timeText.text = "Time: " + (time);
                    stage.visible = false;
                    menuStage.visible = true;
                    state = gameOverState;
                    
                }
            }

            function mainMenu(){
                console.log("Main menu");
                var menuBox = new Graphics(),
                    menuOutline = new Graphics();

                menuBox.beginFill(0x23556b);
                menuBox.drawRect(gameBorder, gameBorder, gameWidth - gameBorder * 2, gameHeight  + 80 );
                menuBox.endFill();

                menuOutline.beginFill(0x62cffc);
                menuOutline.drawRect(gameBorder / 2, gameBorder / 2, gameWidth - gameBorder , gameHeight + 90);
                menuOutline.endFill();
                menuStage.addChild(menuOutline);
                menuStage.addChild(menuBox);

                var menuPadding = 10;
        
                var hardDiff = new Sprite(resources["button.png"].texture),
                medDiff = new Sprite(resources["button.png"].texture),
                easyDiff = new Sprite(resources["button.png"].texture),
                customDiff = new Sprite(resources["button.png"].texture),
                highScore = new Sprite(resources["button.png"].texture);

                gameoverText = new Text(" ", {fontFamily: "Arial", fontSize: 48, fill: "white"});

                var hardText = new Text("Hard", {fontFamily: "Arial", fontSize: 24, fill: "white"}),
                easyText = new Text("Easy", {fontFamily: "Arial", fontSize: 24, fill: "white"}),
                medText = new Text("Medium", {fontFamily: "Arial", fontSize: 24, fill: "white"}),
                highscoreText = new Text("HighScore", {fontFamily: "Arial", fontSize: 24, fill: "white"}),
                customText = new Text("Custom", {fontFamily: "Arial", fontSize: 24, fill: "white"});

                var menuButtonWidth = gameWidth/2-easyDiff.width/2,
                menuButtonHeight = (gameHeight/3);

                
                easyDiff.position.set(gameWidth/2-easyDiff.width/2, menuButtonHeight+ (medDiff.height));
                medDiff.position.set(gameWidth/2-easyDiff.width/2, menuButtonHeight + (medDiff.height * 2) + 10);
                hardDiff.position.set(gameWidth/2-easyDiff.width/2, menuButtonHeight + (medDiff.height * 3) + 20);
                customDiff.position.set(gameWidth/2-easyDiff.width/2, menuButtonHeight + (medDiff.height * 4) + 30);
                highScore.position.set(gameWidth/2-easyDiff.width/2, menuButtonHeight + (medDiff.height * 5) + 40);

                easyText.position.set(gameWidth/2 - easyText.width/2, easyDiff.y + easyText.height/2);
                medText.position.set(gameWidth/2 - medText.width/2, medDiff.y + medText.height/2);
                hardText.position.set(gameWidth/2 - hardText.width/2, hardDiff.y + hardText.height/2);
                highscoreText.position.set(gameWidth/2 - highscoreText.width/2, highScore.y + highscoreText.height/2);
                customText.position.set(gameWidth/2 - customText.width/2, customDiff.y + customText.height/2);

                settingsStage();
                setup();

                easyDiff.interactive = true;
                easyDiff.click = function(mouseData){
                    console.log("Easy difficulty");
                    setLevel(3,2,2);
                }
                medDiff.interactive = true;
                medDiff.click = function(mouseData){
                    console.log("Medium difficulty");
                    setLevel(6,3,2);
                }
                hardDiff.interactive = true;
                hardDiff.click = function(mouseData){
                    console.log("Hard difficulty");
                    setLevel(9,3,3);
                }
                customDiff.interactive = true;
                customDiff.click = function(mouseData){
                    menuStage.visible = false;
                    stage.visible = false;
                    stageSettings.visible = true;
                    state = changeSettings;
                    // renderer.render(stageSettings);
                    console.log("Custome Level");
                    
                }
                highScore.interactive = true;
                highScore.click = function(mouseData){
                    console.log("High Score");
                    
                }

                menuStage.addChild(easyDiff);
                menuStage.addChild(medDiff);
                menuStage.addChild(hardDiff);
                menuStage.addChild(customDiff);
                menuStage.addChild(highScore);
                menuStage.addChild(easyText);
                menuStage.addChild(medText);
                menuStage.addChild(hardText);
                menuStage.addChild(customText);
                menuStage.addChild(highscoreText);
                menuStage.addChild(gameoverText);

                state = menuState;

                renderer.render(menuStage);
                gameLoop();            
            }
            function menuState(){
                renderer.render(menuStage);
            }

            function gameOverState(){
                gameoverText.text = "Final Score: "+  score;
                gameoverText.position.set(gameWidth/2 - gameoverText.width/2, gameHeight/5);
                renderer.render(menuStage);
            }

            function setLevel(bounces, walls, rows){
                timerCount = setInterval(timeLeft,1000);
                numRows = rows;
                bulletBounce = bounces;
                numWalls = walls;
                level();
                score = 0;
                messageScore.text = "Score: " + score;
                menuStage.visible = false;
                stage.visible = true;
                state = play;
            }

            function level(){
                boxes.forEach(function(box){
                    stage.removeChild(box);
                });
                targets.forEach(function(target){
                    stage.removeChild(target);
                });
                stage.removeChild(tpath);
                tpath.answer = false;
                stage.removeChild(tracePath);

                bullets.forEach(function(bullet){
                    stage.removeChild(bullet);
                });
                bullets = [];
                boxes = [];
                targetPath = [];
                targetsHit = []; 
                targets = [];

                createWalls(numWalls);
                var random_angle = 0;
                while(targets.length < minTargets || targetQuad() == false || checkIfPixelPerfect(random_angle) == false){
                    targets = [];
                    random_angle = createTargets();
                }
                targets.forEach(function(target){
                    stage.addChild(target);
                });
            }

            

            function createBullet(angle){
                var bullet = new Graphics();
                bullet.beginFill(0x239569);
                bullet.drawRect(0 , 0, 10, 10);
                bullet.x= (gameWidth / 2) - (bulletHeight * Math.cos(angle));
                bullet.y = gameHeight - (bulletHeight * Math.sin(angle));
                bullet.xv = (Math.cos(angle));
                bullet.yv = (Math.sin(angle));
                bullet.bounce = bulletBounce;
                bullet.endFill();
                return bullet;
            }

            function createLevel(bulletSpeed, bulletBounce, bulletHeight, bulletWidth, wallWidth, wallHeight, numWalls, numTargets){
                this.bulletSpeed = bulletSpeed;
                this.bulletBounce = bulletBounce;
                this.bulletHeight = bulletHeight;
                this.bulletWidth = bulletWidth;
                this.wallWidth = wallWidth;
                this.wallHeight = wallHeight;
                this.numWalls = numWalls;
            }

            function createWalls(numWalls){
                var xsplit = gameWidth / numWalls,
                    ysplit = (gameHeight - 100) / numRows,
                    xPad = xsplit - wallWidth,
                    yPad = ysplit - wallHeight;

                if(numRows == 1){
                    ysplit = (gameHeight - 100) / 2;
                }
                
                for(var i = 0; i < numWalls; i++){
                    for(var j = 0; j < numRows; j++){
                        var randx = Math.floor(Math.random() * xPad) + 1;
                        var randy = Math.floor(Math.random() * yPad) + 1;
                        //Dont make wall in front of gun
                        // if(!((i == Math.floor(numWalls/2)) && j == Math.ceil(numWalls / 2))){ 
                            if(((i*xsplit) + randx) < gameBorder){
                                randx = gameBorder;
                            }else if(((i*xsplit) + randx + wallWidth) > (gameWidth - gameBorder)){
                                randx = gameWidth - gameBorder;
                            }
                            if(((j * ysplit) + randy) < gameBorder){
                                randy = gameBorder;
                            }else if(((j * ysplit) + randy + wallHeight) > (gameHeight - gameBorder)){
                                randy = gameHeight - gameBorder;
                            }
                            createWall((i*xsplit) + randx , (j * ysplit) + randy, wallWidth, wallHeight);
                        // }
                    }
                } 
            }
            

            function createWall(xloc,yloc,w,h){
                var box = new Sprite(resources["boxsmall.png"].texture);
                box.x = xloc;
                box.y = yloc;
                box.xpos = xloc;
                box.ypos = yloc;

                boxes.push(box);
                stage.addChild(box);
            }

            function createTargets(){
                //Convert random angle to rad
                console.log("bounces: " + bulletBounce);
                var randAngle = (Math.floor(Math.random() * 175) + 1) * Math.PI / 180;
                targetPath =  new createPath((gameWidth / 2), gameHeight, randAngle, bulletBounce, 10, 10, bulletSpeed);
                targetPath = getPathHits(targetPath);

                var startx = gameWidth / 2;
                var starty = gameHeight;
                targetPath.cords.forEach(function(cord){ 
                    var pathWidth = (cord.xpos - startx),
                        pathHeight = (cord.ypos - starty);
                        
                    var testx, texty;
                    var foundPos = false;
                    var loopCount = 0;

                    //Find and create location of target
                    while(foundPos == false && loopCount < 10){
                        console.log("creating level");
                        // console.log("loop count: " + loopCount);
                        var randx = Math.floor(Math.random() * pathWidth) + 1,
                            randy = Math.floor(Math.random() * pathHeight) + 1,
                            target = new Sprite(resources["targetsmall.png"].texture);

                        var m = (pathHeight/pathWidth),
                            b = cord.ypos - (m * cord.xpos),
                            ypos;
                        if(startx > cord.xpos){
                            testx = cord.xpos - randx;
                        }else{
                            testx = cord.xpos - randx;
                        }

                        ypos = m * testx + b;                     
                        target.x = (testx - target.width / 2);
                        target.y = ypos - target.height / 2;

                        if(!hitTargetOnPath(target)){
                            targets.push(target);
                            foundPos = true;
                        }else{
                            loopCount++;
                        }
                    }
                    startx = cord.xpos;
                    starty = cord.ypos;
                });
                return randAngle;
            }

            function drawAnswer(){
                tpath.clear();
                tpath.answer = true;
                tpath.lineStyle(2, 0x0000FF, 1);
                tpath.moveTo((gameWidth / 2),gameHeight);
                targetPath.cords.forEach(function(cord){
                    tpath.lineTo(cord.xpos, cord.ypos);
                });
                stage.addChild(tpath);
            }

            function changeMain(){
                renderer.render(menuStage);
            }

            function changeSettings(){
                renderer.render(stageSettings);                
            }

            //Change padding of answer
            function checkIfPixelPerfect(random_angle){
                //Add angle difference to answer
                var addAngle = .5 * Math.PI / 180 
                var bullet = createBullet(random_angle + addAngle);
                targetsHit = [];
                
                while(bulletBounce > 0){
                    hitTarget(bullet);
                    hitBox(bullet);
                    hitWall(bullet);
                    
                    if(bullet.bounce > 0){
                        bullet.x -= (bulletSpeed * bullet.xv);
                        bullet.y -= (bulletSpeed * bullet.yv);
                    }else{
                        if(targets.length == 0){
                            targetsHit.forEach(function(target){
                                targets.push(target);
                            });
                            targetsHit = [];
                            return true;
                        }else{
                            targets = [];
                            targetsHit = [];
                            return false;
                        }
                    }
                }
            }

            //Target in all 4 quads
            function targetQuad(){
                var q1 = false,
                    q2 = false, 
                    q3 = false,
                    q4 = false;
                    quad = 0;

                targets.forEach(function(target){
                    if(target.x < (gameWidth /2) && target.y < (gameHeight / 2)){
                        if(!q1){
                            q1 = true;
                            quad++;
                        }
                    }else if(target.x > (gameWidth /2) && target.y < (gameHeight / 2)){
                        if(!q2){
                            q2 = true;
                            quad++;
                        }
                    }else if(target.x < (gameWidth /2) && target.y > (gameHeight / 2)){
                        if(!q3){
                            q3 = true;
                            quad++;
                        }
                    }else if(target.x > (gameWidth /2) && target.y > (gameHeight / 2)){
                        if(!q4){
                            q4 = true;
                            quad++;
                        }
                    }
                });

                


                if(quad >= minTargets || quad > 3){
                    return true;
                }else{
                    return false;
                }



            }

            function createTarget(x ,y){   
                var target = new Sprite(resources["targetsmall.png"].texture);
                target.x = x;
                target.y = y;
                targets.push(target);
                stage.addChild(target);
            }

            function settingsStage(){
                var sDoneText = new Text("Play", {fontFamily: "Arial", fontSize: 24, fill: "white"}),
                    sDoneBox = new Sprite(resources["button.png"].texture),
                    sRowText = new Text("Rows: " + numRows, {fontFamily: "Arial", fontSize: 24, fill: "white"}),
                    sRowAdd = new Sprite(resources["boxsmall.png"].texture),
                    sRowSub = new Sprite(resources["boxsmall.png"].texture),
                    sBounceAdd = new Sprite(resources["boxsmall.png"].texture),
                    sBounceSub = new Sprite(resources["boxsmall.png"].texture),
                    sBounceText =  new Text("Bounces: " + bulletBounce, {fontFamily: "Arial", fontSize: 24, fill: "white"}),
                    sBoxesAdd = new Sprite(resources["boxsmall.png"].texture),
                    sBoxesSub = new Sprite(resources["boxsmall.png"].texture),
                    sBoxesText =  new Text("Boxes Per Row: " + numWalls, {fontFamily: "Arial", fontSize: 24, fill: "white"});




                    sBounceText.position.set(gameWidth/2 - sBounceText.width - 20, 100);
                    sBounceAdd.x = gameWidth/2 + sBounceAdd.width;
                    sBounceAdd.y = 88;
                    sBounceAdd.interactive = true;
                    sBounceAdd.click = function(mouseData){
                        if(bulletBounce < 10){
                            if(bulletBounce == 0){
                                stageSettings.addChild(sBounceSub);
                            }
                            bulletBounce++;
                            sBounceText.text = "Bounces: " + bulletBounce;
                            if(bulletBounce == 10){
                                stageSettings.removeChild(sBounceAdd);
                            }
                        }
                        renderer.render(stageSettings);
                        
                        
                    }
                    sBounceSub.x = gameWidth/2 ;
                    sBounceSub.y = 88;
                    sBounceSub.interactive = true;
                    sBounceSub.click = function(mouseData){
                        if(bulletBounce > 0){
                            if(bulletBounce == 10){
                                stageSettings.addChild(sBounceAdd);
                            }
                            bulletBounce--;
                            sBounceText.text = "Bounces: " + bulletBounce;
                            console.log("add");
                            if(bulletBounce == 0){
                                stageSettings.removeChild(sBounceSub);
                            }
                        }

                        renderer.render(stageSettings);
                        
                    }

                    sBoxesText.position.set(gameWidth/2 - sBoxesText.width - 20, 200);
                    sBoxesAdd.x = gameWidth/2 + sBounceAdd.width;
                    sBoxesAdd.y = 188;
                    sBoxesAdd.interactive = true;
                    sBoxesAdd.click = function(mouseData){
                        if(numWalls < 4){
                            if(numWalls == 0){
                                stageSettings.addChild(sBoxesSub);
                            }
                            numWalls++;                        
                            sBoxesText.text = "Boxes Per Row: " + numWalls;
                            if(numWalls == 4){
                                stageSettings.removeChild(sBoxesAdd);
                            }
                        }
                        renderer.render(stageSettings);
                    }
                    sBoxesSub.x =  gameWidth/2;
                    sBoxesSub.y = 188;
                    sBoxesSub.interactive = true;
                    sBoxesSub.click = function(mouseData){
                        if(numWalls > 0){ 
                            if(numWalls == 4){
                                stageSettings.addChild(sBoxesAdd);
                            }
                            numWalls--;
                            sBoxesText.text = "Boxes Per Row: " + numWalls;
                            if(numWalls == 0){
                                stageSettings.removeChild(sBoxesSub);
                            }
                        }
                        renderer.render(stageSettings);
                    }

                    sRowText.position.set(gameWidth/2 - sRowText.width - 20, 300);
                    sRowAdd.x = gameWidth/2 + sRowAdd.width;
                    sRowAdd.y = 288;
                    sRowAdd.interactive = true;
                    sRowAdd.click = function(mouseData){
                        if(numRows < 3){
                            if(numRows == 1){
                                stageSettings.addChild(sRowSub);
                            }
                            numRows++;
                            sRowText.text = "Rows: " + numRows;
                            if(numRows == 3){
                                stageSettings.removeChild(sRowAdd);
                            }
                        }
                        renderer.render(stageSettings);
                    }
                    sRowSub.x =  gameWidth/2;
                    sRowSub.y = 288;
                    sRowSub.interactive = true;
                    sRowSub.click = function(mouseData){
                        if(numRows > 1){
                            if(numRows == 3){
                                stageSettings.addChild(sRowAdd);
                            }
                            numRows--;
                            sRowText.text = "Rows: " + numRows;
                            if(numRows == 1){
                                stageSettings.removeChild(sRowSub);
                            }
                        }
                        renderer.render(stageSettings);
                        
                    }

                    sDoneText.position.set(gameWidth/2 - sDoneText.width/2,412);
                    sDoneBox.x = gameWidth/2 - sDoneBox.width/2;
                    sDoneBox.y = 400;
                    sDoneBox.interactive = true;
                    sDoneBox.click = function(mouseData){
                        stageSettings.visible = false;
                        menuStage.visible = false;
                        stage.visible = true;
                        state = play;
                        level();
                    }

                    stageSettings.addChild(sDoneText);
                    stageSettings.addChild(sDoneBox);
                    if(bulletBounce > 0){
                        stageSettings.addChild(sBounceSub);                        
                    }
                    if(bulletBounce < 10){
                        stageSettings.addChild(sBounceAdd);    
                    }
                    stageSettings.addChild(sBounceText);
                    if(numWalls > 0){
                        stageSettings.addChild(sBoxesSub);
                    }
                    if(numWalls < 4){
                        stageSettings.addChild(sBoxesAdd);
                    }
                    stageSettings.addChild(sBoxesText);
                    stageSettings.addChild(sRowText);
                    if(numRows > 1){
                        stageSettings.addChild(sRowSub);
                        
                    }
                    if(numRows < 4){
                        stageSettings.addChild(sRowAdd);
                    }
            }

            function play(){
                messageTargets.text = "Targets: " + targets.length;       
                // timeText.text = "Time: " + timeElapsed;
                // timeElapsed = time++/120;
                
                bullets.forEach(function(bullet){
                    hitTarget(bullet);
                    hitBox(bullet);
                    hitWall(bullet);
                    
                    messageBounce.text = "Bounces: " + bullet.bounce;                       
                    if(bullet.bounce > 0){
                        bullet.x -= (bulletSpeed * bullet.xv);
                        bullet.y -= (bulletSpeed * bullet.yv);
                    }else{
                        bullet.clear();
                        bullets.pop();
                        if(targets.length == 0){
                            if(!tpath.answer){
                                score += targetsHit.length * boxes.length;
                                // score++;  
                            }
                            level();
                            messageScore.text = "Score: " + score;
                            messageBounce.text = "Bounces: " + bulletBounce;
                        }else{
                            targetsHit.forEach(function(target){
                                targets.push(target);
                                stage.addChild(target);
                            });
                            targetsHit = [];
                            messageBounce.text = "Bounces: " + bulletBounce;
                            
                        }
                    }
                });
                renderer.render(stage);
            }

            
            
            function gameLoop(){
                requestAnimationFrame(gameLoop);
                state();
            }

            function createPath(xpos, ypos, angle, bounce, width, height, speed){
                this.xpos = xpos;
                this.ypos = ypos;
                this.bulletWidth = width;
                this.bulletHeight = height;
                this.xv = Math.cos(angle);
                this.yv = Math.sin(angle);
                this.bulletSpeed = speed;
                this.angle = angle;
                this.bounce = bounce;
                this.cords = [];
            }
            
            function getPathHits(path){
                while(path.bounce > 0){
                    if(path.xpos < gameBorder || (path.xpos + path.bulletWidth) > (gameWidth - gameBorder)){
                        path.bounce--;
                        path.xv *= -1;
                        var cord = {
                            xpos: path.xpos,
                            ypos: path.ypos
                        }
                        path.cords.push(cord);
                    }
                    else if(path.ypos < gameBorder || (path.ypos) > gameHeight){
                        path.bounce--;
                        path.yv *= -1;  
                        var cord = {
                            xpos: path.xpos,
                            ypos: path.ypos
                        }
                        path.cords.push(cord);             
                    }else{
                        boxes.forEach(function(box){
                            //Check if there a collision happening
                            if((path.ypos + path.bulletHeight) > box.ypos && 
                                path.ypos < (box.ypos + box.height) && 
                                (path.xpos + path.bulletWidth) > box.xpos && 
                                path.xpos < (box.xpos + box.width)){
                                
                                //Find axis of collision
                                var vectorX = (path.xpos + Math.abs(path.bulletWidth / 2)) - (box.xpos + Math.abs(box.width / 2));
                                var vectorY = (path.ypos + Math.abs(path.bulletHeight / 2)) - Math.abs(box.ypos + (box.height / 2));
                                var totalHalfWidth = Math.abs(path.bulletWidth / 2) + Math.abs(box.width / 2);
                                var totalHalfHeight = Math.abs(path.bulletHeight /2 ) +  Math.abs(box.height / 2);
                                var overlapX = totalHalfWidth - Math.abs(vectorX);
                                var overlapY =  totalHalfHeight - Math.abs(vectorY);

                                //Collsion on Top/Bottom
                                if(overlapX >= overlapY){
                                    if(vectorY > 0){
                                        path.ypos += overlapY;
                                        
                                    }else{
                                        path.ypos -= overlapY;
                                        
                                    }
                                    path.yv *= -1;
                                    var cord = {
                                        xpos: path.xpos,
                                        ypos: path.ypos
                                    }
                                    path.cords.push(cord); 
                                }
                                //Collsion on Left/Right
                                else{
                                    if(vectorX > 0){
                                        path.xpos += overlapX;
                                    }else{
                                        path.xpos -= overlapX;
                                    }
                                    path.xv *= -1;
                                    var cord = {
                                        xpos: path.xpos,
                                        ypos: path.ypos
                                    }
                                    path.cords.push(cord); 
                                }
                                path.bounce--;
                            }
                        });
                    }
                    path.xpos -= (path.bulletSpeed * path.xv); 
                    path.ypos -= (path.bulletSpeed * path.yv);             
                }
                return path;   
            }
            
            function hitTarget(bullet){
                var hit, totalWidth, totalHeight, centerWidth, centerHeight;
                var deleteIndex = 0;
                targets.forEach(function(target){
                    if((bullet.y  + bullet.height) > target.y && 
                        bullet.y < (target.y + target.height) && 
                        (bullet.x + bullet.width) > target.x && 
                        bullet.x < (target.x + target.width)){
                            stage.removeChild(target);
                            targets.splice(deleteIndex, 1);
                            targetsHit.push(target);
                    }else{
                        deleteIndex++;
                    }
                });
            }

            function hitTargetOnPath(target){
                var hit = false;
                boxes.forEach(function(box){
                    if(target.x < gameBorder || (target.x + target.width) > (gameWidth - gameBorder)){
                        hit =  true;
                    }
                    if(target.y < gameBorder || (target.y + target.height)  > gameHeight){
                        hit =  true;
                    }
                    //Check if there a collision happening
                    if((target.y + target.height) > box.ypos && 
                        target.y < (box.ypos + box.height) && 
                        (target.x + target.width) > box.xpos && 
                        target.x < (box.xpos + box.width)){
                            hit = true;
                    }
                });
                targets.forEach(function(target2){
                    if((target.y + target.height) > target2.y && 
                    target.y < (target2.y + target2.height) && 
                    (target.x + target.width) > target2.x && 
                    target.x < (target2.x + target2.width)){
                            hit = true;
                    }
                });
                return hit;
            } 

            function hitBox(bullet){
                boxes.forEach(function(box){
                    //Check for collision
                    if((bullet.y  + bullet.height) > box.ypos && 
                        bullet.y < (box.ypos + box.height) && 
                        (bullet.x + bullet.width) > box.xpos && 
                        bullet.x < (box.xpos + box.width)){
                            //Find axis of collision
                            var vectorX = (bullet.x + Math.abs(bullet.width / 2)) - (box.xpos + Math.abs(box.width / 2));
                            var vectorY = (bullet.y + Math.abs(bullet.height / 2) ) - Math.abs(box.ypos + (box.height / 2));
                            var totalHalfWidth = Math.abs(bullet.width / 2) + Math.abs(box.width / 2);
                            var totalHalfHeight = Math.abs(bullet.height / 2) + Math.abs(box.height / 2);
                            var overlapX = totalHalfWidth - Math.abs(vectorX);
                            var overlapY =  totalHalfHeight - Math.abs(vectorY);

                            //Collsion on Top/Bottom
                            if(overlapX >= overlapY){
                                if(vectorY > 0){
                                    bullet.y += overlapY;
                                    
                                }else{
                                    bullet.y -= overlapY;
                                }
                                    bullet.yv *= -1;
                            }
                            //Collision on left/right
                            else{
                                if(vectorX > 0){
                                    bullet.x += overlapX;
                                }else{
                                    bullet.x -= overlapX;
                                }
                                    bullet.xv *= -1;
                            }
                        bullet.bounce--;
                    }
                });
            }

            function hitWall(bullet) {
                if(bullet.x < gameBorder || (bullet.x + bulletWidth) > (gameWidth - gameBorder)){
                    bullet.bounce--;
                    bullet.xv *= -1;
                }
                if(bullet.y < gameBorder || bullet.y > gameHeight){
                    bullet.bounce--;
                    bullet.yv *= -1;
                }         
            }
            
        </script>
    </body>
</html>